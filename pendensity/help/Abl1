Abl1               package:pendensity               R Documentation

_C_a_l_c_u_l_a_t_i_n_g _t_h_e _f_i_r_s_t _d_e_r_i_v_a_t_i_v_e _o_f _t_h_e _p_e_n_d_e_n_s_i_t_y _l_i_k_e_l_i_h_o_o_d _f_u_n_c_t_i_o_n _w._r._t. _p_a_r_a_m_e_t_e_r _b_e_t_a

_D_e_s_c_r_i_p_t_i_o_n:

     Calculating the first derivative of the pendensity likelihood
     function w.r.t. parameter beta.

_U_s_a_g_e:

     Abl1(penden.env)

_A_r_g_u_m_e_n_t_s:

penden.env: Containing all information, environment of pendensity()

_D_e_t_a_i_l_s:

     We calculate the first derivative of the pendensity likelihood
     function w.r.t. the parameter beta. The calculation of the first
     derivative of the pendensity likelihood function w.r.t. parameter
     beta is done in four steps. The first derivative equals in the
     case of covariates

                       s(beta) = sum si(beta),

     where

    s[i](beta) = Z^T(x[i]) C^T (x[i],beta) phi[i] / f(y[i]|x[i]).


      Without covariates, the matrix 'Z' doesn't appear. Starting
     density calculation, the groupings of the covariates are indexed
     in the main program. The groupings are saved in 'x.factor'.
     Creating an index that reports which response belongs to which
     covariate group, saving in 'Z.index'. Therefore, one can link to
     the rows in the object 'ck' to calculate the matrix 'C.bold',
     which depends only on the grouping of the covariate. Without any
     covariate, 'C.bold' is equal for every observation.
      The calculation of the first derivative of the pendensity
     likelihood function w.r.t. parameter beta is done in four steps.
     Firstly, we calculate the matrix 'C.bold', depending on the groups
     of 'x.factor'.
      Secondly, for calculating we need the fitted values of each
     observation, 'f.hat'. These values are calculated for the actual
     parameter set beta in the program 'f.hat'. Of course, we need the
     value of the base for each observation, phi[i].
      Moreover, for the case of conditional density estimation, we need
     a Z-Matrix, due to the rules for derivations of the function
     'exp()'. This Z-matrix doesn't appear directly in the
     calculations. We construct the multiplication with this Z-matrix
     with using an outer product between the corresponding grouping in
     'x.factor' and the product of the corresponding values 'C.bold'
     and 'base.den', devided with the fitted value 'f.hat'. Finally, we
     add some penalty on the derivative, which is calculated in the
     fourth step. The penalty equals {-lambda D_m beta }.
      For later use, we save the unpenalized first derivative as a
     matrix, in which the i-th column contains the first derivative of
     the pendensity likelihood function, evaluated for the i-th value
     of the response. The needed values are saved in the environment.

_V_a_l_u_e:

Abl1.cal: matrix, in which the i-th column contains the first
          derivative, evaluated for the i-th value of the response
          variable without penalty. Needed for calculating the second
          order derivative, called s(beta)

Abl1.pen: first order derivation of the penalized likelihood function
          w.r.t. parameter beta, called 

                               sp(beta)


f.hat.val: fitted values of the response for actual parameter beta,
          called hat{f}

_A_u_t_h_o_r(_s):

     Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>

_R_e_f_e_r_e_n_c_e_s:

     Penalized Density Estimation, Kauermann G. and Schellhase C.
     (2009), to appear.

